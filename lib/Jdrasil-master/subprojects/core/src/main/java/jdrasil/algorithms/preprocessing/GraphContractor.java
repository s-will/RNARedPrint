/*
 * Copyright (c) 2016-present, Max Bannach, Sebastian Berndt, Thorsten Ehlers
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
 * associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or
 * substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
 * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT
 * OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
package jdrasil.algorithms.preprocessing;

import java.util.HashSet;
import java.util.Set;
import java.util.Stack;

import jdrasil.graph.Bag;
import jdrasil.graph.Graph;
import jdrasil.graph.GraphFactory;
import jdrasil.graph.TreeDecomposition;
import jdrasil.graph.invariants.Matching;

/**
 * It is a well known fact that tree width is closed under taking minors, i.\,e., if \(H\) is a minor of \(G\), then 
 * \(\mathrm{tw}(H)\leq \mathrm{tw}(G)\). Many algorithms that compute tree decompositions use this fact in some way.
 * 
 * The GraphContractor class computes a matching of the input graph, and contracts it. The result is a minor (which is of course much smaller)
 * and wish is returned. Given a tree decomposition of this minor, a tree decomposition for the original graph is generated by decontract 
 * the edges within the bags of the decomposition. The result is a valid (but not optimal) tree decomposition of the input graph. Furthermore,
 * if the decomposition of the minor has width \(k\), the width of the final decomposition is at most \(2k+1\).
 * 
 * @author Max Bannach
 */
public class GraphContractor<T extends Comparable<T>> extends Preprocessor<T> {

	/** Remember some informations about every contraction, such that we can revoke them later. */
	private Stack<Graph<T>.ContractionInformation> contractions;
	
	/**
	 * @param graph
	 */
	public GraphContractor(Graph<T> graph) {
		super(graph);
	}

	/* (non-Javadoc)
	 * @see jdrasil.algorithms.preprocessing.Preprocessor#computeGraphs()
	 */
	@Override
	protected Set<Graph<T>> computeGraphs() {
		
		// result
		Graph<T> contracted = GraphFactory.copy(graph);
		contractions = new Stack<>(); // remember changes to revoke them
		
		// first compute a maximal matching
		Matching<T> M = new Matching<>(contracted);
		
		// contract the matching
		for (T v : M.getModel().keySet()) {
			T w = M.getModel().get(v);
			if (v.compareTo(w) > 0) continue;
			contractions.push(contracted.contract(v, w));
		}
		
		// done
		Set<Graph<T>> result = new HashSet<>();
		result.add(contracted);
		return result;
	}

	/* (non-Javadoc)
	 * @see jdrasil.algorithms.preprocessing.Preprocessor#glueDecompositions()
	 */
	@Override
	protected TreeDecomposition<T> glueDecompositions() {
		
		// there will only be one decomposition, take it
		TreeDecomposition<T> decomposition = treeDecompositions.iterator().next();
		
		// undo contractions on tree decomposition
		while (!contractions.isEmpty()) {
			
			// get contraction
			Graph<T>.ContractionInformation info = contractions.pop();
			
			// decontract graph
			decomposition.getGraph().deContract(info);
			
			// decontract decomposition
			for (Bag<T> bag : decomposition.getBags()) {
				if (bag.contains(info.v)) {
					bag.vertices.add(info.w);
					int size = bag.vertices.size() - 1;
					if (size > decomposition.getWidth()) {
						decomposition.setWidth(size);
					}
				}
			}			
		}
		decomposition.setN(decomposition.getGraph().getVertices().size());
		
		// done
		return decomposition;
	}

}
